use evdev_rs::{Device, DeviceWrapper};
use std::fs::File;
use std::future::Future;
use std::os::fd::AsRawFd;
use std::path::PathBuf;
use std::pin::Pin;
use std::sync::Arc;
use tokio::sync::{oneshot, Notify};
use tokio::time::Duration;

use crate::errors::{self, LeftError, Result};

pub struct EvDev {
    pub devices: Vec<File>,
    pub task_notify: Arc<Notify>,
    _task_guards: Vec<oneshot::Receiver<()>>,
}

impl EvDev {
    pub fn new() -> Self {
        let task_notify = Arc::new(Notify::new());

        let mut task_guards: Vec<oneshot::Receiver<()>> = vec![];
        let mut devices = vec![];
        for entry in errors::exit_on_error!(std::fs::read_dir("/dev/input")) {
            let entry = errors::exit_on_error!(entry);

            if !entry
                .file_name()
                .to_str()
                .unwrap_or("")
                .starts_with("event")
            {
                continue;
            }
            let path = entry.path();
            if path.is_dir() {
                continue;
            }

            match device_with_path(path) {
                Ok(item) => devices.push(item),
                Err(err) => tracing::error!("{:#}", err),
            }
        }
        devices
            .iter()
            .filter(|device| {
                device.has(evdev_rs::enums::EventType::EV_KEY)
                    && device.phys().unwrap().contains("input0")
            })
            .for_each(|device| {
                let (guard, task_guard) = oneshot::channel();
                let notify = task_notify.clone();
                const SERVER: mio::Token = mio::Token(0);
                let fd = device.file().as_raw_fd();
                let mut poll = errors::exit_on_error!(mio::Poll::new());
                let mut events = mio::Events::with_capacity(1);
                errors::exit_on_error!(poll.registry().register(
                    &mut mio::unix::SourceFd(&fd),
                    SERVER,
                    mio::Interest::READABLE,
                ));
                let timeout = Duration::from_millis(100);
                tokio::task::spawn_blocking(move || loop {
                    if guard.is_closed() {
                        println!("Bye");
                        return;
                    }

                    if let Err(err) = poll.poll(&mut events, Some(timeout)) {
                        tracing::warn!("Xlib socket poll failed with {:?}", err);
                        continue;
                    }

                    events
                        .iter()
                        .filter(|event| SERVER == event.token())
                        .for_each(|_| notify.notify_one());
                });
                task_guards.push(task_guard);
            });

        println!("Setup keyboard watcher");

        Self {
            devices: files,
            task_notify,
            _task_guards: task_guards,
        }
    }

    pub fn wait_readable(&mut self) -> Pin<Box<dyn Future<Output = ()>>> {
        let task_notify = self.task_notify.clone();
        Box::pin(async move {
            task_notify.notified().await;
        })
    }
}

pub fn device_with_path(path: PathBuf) -> Result<(Device, File)> {
    let f = std::fs::File::open(&path)?;
    Ok((Device::new_from_path(path)?, f))
}
